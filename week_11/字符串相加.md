# 字符串相加

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：

num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。



##### 解题思路：双指针法

##字符’0‘~’9‘ 对应ASCII码是48 ~ 57。

从字符串的尾部，从后往前对两个字符串进行相加处理。

需要注意的是：字符串中的数字是属于字符，但字符对应的ASCII是数字，只需要取出字符串中的数字字符，然后减去 ’0‘ 就可以得到该’数字字符‘对应的真正数字。

从后往前先分别对两个字符串的数字字符进行处理后相加，若sum大于10，则标记flag=1（下一位需要加一），sum = sum/10。



```c
char * addStrings(char * num1, char * num2){
    int i = strlen(num1)-1,j = strlen(num2)-1;
    char *res;
    int maxlen = (i>j ? i+1:j+1);
    int k = maxlen+1;
    int flag = 0;
    res = (char*)malloc(sizeof(char) * (maxlen+2));
    if(!res) return NULL;
    memset(res, 0, sizeof(char) * (maxlen + 2));
    while(i>=0 || j>=0)
    {
        int sum = flag;
        sum += (i >= 0) ? num1[i--] - '0' : 0;
        sum += (j >= 0) ? num2[j--] - '0' : 0;//此处有个十分惨痛的教训！！！我不小心将num2写成了num1，然后测试代码一直提示数组越界。我愣是被这个小失误卡住了半个多小时！！！！以后一定要小心了，这种细微差别的代码错误实在太难找了！
        res[--k] = sum % 10 + '0';
        flag = sum / 10;
    }
    if(flag)
    {
        res[0] = '1';
        return res;
    }
    else return res + 1;
}
```

