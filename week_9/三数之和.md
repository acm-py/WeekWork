---
title: 三数之和
tags:
- 数组
categories:
- 双指针
----
给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。


***
> 输入: [-1, 0, 1, 2, -1, -4]
> 输出: [
  [-1, 0, 1],
  [-1, -1, 2]
]

解释:给定 nums = [-1, 0, 1, 2, -1, -4]
满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]

举例:
>输入: [-1,0,1,2,-1,-4]
输出:[[-1,-1,2],[-1,0,1]]


个人感悟:实际上用会以后才明白就是固定一个位置让另外两指针从两端到相遇的过程，不过看代码的时候用了不少时间。
***
C++实现
***
'''

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(),nums.end());//将nums排序，由于快排所以时间复杂度为(O(n*logn))
        int l=0,m,r;//l为左指针，m为中间(l,r]上指向最小数的指针，r为(l,r)上指向最大数的指针
        for(l=0;l+1<nums.size();l++)//固定l指针依次遍历m+r的各个值是否满足条件
        {           
            m=l+1;
            r=nums.size()-1;
            if(nums[l]>0||nums[r]<0)//最小数大于0或最大数小于0则不可能满足和为0的结果
              break;
            if(l>0&&nums[l]==nums[l-1])//若nums[l]=nums[l-1],则很明显m+r的遍历结果是重复的，故直接跳过
              continue;
            while(m<r)
            {
               int s=nums[l]+nums[m]+nums[r];//记录结果
               if(s>0)
                   r--;//最大值减小进行尝试
               else if(s<0)//最小值增大进行尝试
                  m++;
               else
               {
                 vector<int> list;
                  list.push_back(nums[l]);
                  list.push_back(nums[m]);
                  list.push_back(nums[r]);                  
                  result.push_back(list);//满足要求添加结果，同时因为数组已排序故同样的结果需要去掉。
                  while (m<r && nums[m] == nums[m+1]) m++; // 去重
                  while (m<r && nums[r] == nums[r-1]) r--; // 去重
                  m++;
                  r--;
               }
            }

        }
        return result;
      }
    
};   
'''
***
执行用时 :
140 ms
, 在所有 cpp 提交中击败了
76.03%
的用户
内存消耗 :
18 MB
, 在所有 cpp 提交中击败了
27.12%
的用户
***