---
title: 合并两个有序链表
tags:
- 链表
categories:
- 数据结构
---
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
### 例如
> 输入：1->2->4, 1->3->4
> 输出：1->1->2->3->4->4
***
看完题第一反应是依次遍历并比较两个链表。

python非递归实现
***

''' 

    class Solution(object):
        def mergeTwoLists(self, l1, l2):
            """
            :type l1: ListNode
            :type l2: ListNode
            :rtype: ListNode
            """
            res=ListNode(None)
            node = res
            while l1 and l2:
                if l1.val <l2.val:
                    node.next,l1 =l1,l1.next
                else:
                    node.next,l2=l2,l2.next
                node =node.next
            if l1:
                node.next=l1
            else:
                node.next=l2
            return res.next
            

'''
***

执行用时 :
20 ms
, 在所有 python 提交中击败了
96.51%
的用户
内存消耗 :
11.9 MB
, 在所有 python 提交中击败了
13.90%
的用户
***
python 递归实现
***
'''

    class Solution(object):
        def mergeTwoLists(self, l1, l2):
            """
            :type l1: ListNode
            :type l2: ListNode
            :rtype: ListNode
            """
            if l1==None and l2==None:
                return None
            if l1==None:
                return l2
            if l2==None:
                return l1
            if l1.val<=l2.val:
                l1.next=self.mergeTwoLists(l1.next,l2)
                return l1
            else:
                l2.next=self.mergeTwoLists(l1,l2.next)
                return l2

'''
***
C语言实现
'''

    struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2)
    {
    
        if(l1==NULL)
        return l2;
        if(l2==NULL)
            return l1;
        if(l1->val < l2->val)
        {
            l1->next = mergeTwoLists(l1->next,l2);
            return l1;
        }
        else
        {
            l2->next = mergeTwoLists(l1,l2->next);
            return l2;
        }
    
    }
    
'''
***
执行用时 :8 ms, 在所有 c 提交中击败了62.56%的用户内存消耗 :7.4 MB
, 在所有 c 提交中击败了82.89%的用户。
不管时间复杂度还是空间复杂度，都是C遥遥领先
***